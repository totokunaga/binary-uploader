// Code generated by MockGen. DO NOT EDIT.
// Source: ./server/internal/usecase/interface.go
//
// Generated by this command:
//
//	mockgen -source=./server/internal/usecase/interface.go -destination=./server/internal/mock/mock_usecase.go -package mock
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	entity "github.com/tomoya.tokunaga/server/internal/domain/entity"
	error "github.com/tomoya.tokunaga/server/internal/domain/entity/error"
	usecase "github.com/tomoya.tokunaga/server/internal/usecase"
	gomock "go.uber.org/mock/gomock"
)

// MockFileGetUseCase is a mock of FileGetUseCase interface.
type MockFileGetUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockFileGetUseCaseMockRecorder
	isgomock struct{}
}

// MockFileGetUseCaseMockRecorder is the mock recorder for MockFileGetUseCase.
type MockFileGetUseCaseMockRecorder struct {
	mock *MockFileGetUseCase
}

// NewMockFileGetUseCase creates a new mock instance.
func NewMockFileGetUseCase(ctrl *gomock.Controller) *MockFileGetUseCase {
	mock := &MockFileGetUseCase{ctrl: ctrl}
	mock.recorder = &MockFileGetUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileGetUseCase) EXPECT() *MockFileGetUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockFileGetUseCase) Execute(ctx context.Context) ([]string, error.CustomError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error.CustomError)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockFileGetUseCaseMockRecorder) Execute(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockFileGetUseCase)(nil).Execute), ctx)
}

// ExecuteGetStats mocks base method.
func (m *MockFileGetUseCase) ExecuteGetStats(ctx context.Context, fileName string) (*entity.File, error.CustomError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteGetStats", ctx, fileName)
	ret0, _ := ret[0].(*entity.File)
	ret1, _ := ret[1].(error.CustomError)
	return ret0, ret1
}

// ExecuteGetStats indicates an expected call of ExecuteGetStats.
func (mr *MockFileGetUseCaseMockRecorder) ExecuteGetStats(ctx, fileName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteGetStats", reflect.TypeOf((*MockFileGetUseCase)(nil).ExecuteGetStats), ctx, fileName)
}

// MockFileUploadUseCase is a mock of FileUploadUseCase interface.
type MockFileUploadUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockFileUploadUseCaseMockRecorder
	isgomock struct{}
}

// MockFileUploadUseCaseMockRecorder is the mock recorder for MockFileUploadUseCase.
type MockFileUploadUseCaseMockRecorder struct {
	mock *MockFileUploadUseCase
}

// NewMockFileUploadUseCase creates a new mock instance.
func NewMockFileUploadUseCase(ctrl *gomock.Controller) *MockFileUploadUseCase {
	mock := &MockFileUploadUseCase{ctrl: ctrl}
	mock.recorder = &MockFileUploadUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileUploadUseCase) EXPECT() *MockFileUploadUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockFileUploadUseCase) Execute(ctx context.Context, input usecase.FileUploadUseCaseExecuteInput) error.CustomError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error.CustomError)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockFileUploadUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockFileUploadUseCase)(nil).Execute), ctx, input)
}

// ExecuteFailRecovery mocks base method.
func (m *MockFileUploadUseCase) ExecuteFailRecovery(ctx context.Context, fileID, chunkID uint64) error.CustomError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteFailRecovery", ctx, fileID, chunkID)
	ret0, _ := ret[0].(error.CustomError)
	return ret0
}

// ExecuteFailRecovery indicates an expected call of ExecuteFailRecovery.
func (mr *MockFileUploadUseCaseMockRecorder) ExecuteFailRecovery(ctx, fileID, chunkID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteFailRecovery", reflect.TypeOf((*MockFileUploadUseCase)(nil).ExecuteFailRecovery), ctx, fileID, chunkID)
}

// ExecuteInit mocks base method.
func (m *MockFileUploadUseCase) ExecuteInit(ctx context.Context, input usecase.FileUploadUseCaseExecuteInitInput) (*entity.File, []*entity.FileChunk, error.CustomError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteInit", ctx, input)
	ret0, _ := ret[0].(*entity.File)
	ret1, _ := ret[1].([]*entity.FileChunk)
	ret2, _ := ret[2].(error.CustomError)
	return ret0, ret1, ret2
}

// ExecuteInit indicates an expected call of ExecuteInit.
func (mr *MockFileUploadUseCaseMockRecorder) ExecuteInit(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteInit", reflect.TypeOf((*MockFileUploadUseCase)(nil).ExecuteInit), ctx, input)
}

// MockFileDeleteUseCase is a mock of FileDeleteUseCase interface.
type MockFileDeleteUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockFileDeleteUseCaseMockRecorder
	isgomock struct{}
}

// MockFileDeleteUseCaseMockRecorder is the mock recorder for MockFileDeleteUseCase.
type MockFileDeleteUseCaseMockRecorder struct {
	mock *MockFileDeleteUseCase
}

// NewMockFileDeleteUseCase creates a new mock instance.
func NewMockFileDeleteUseCase(ctrl *gomock.Controller) *MockFileDeleteUseCase {
	mock := &MockFileDeleteUseCase{ctrl: ctrl}
	mock.recorder = &MockFileDeleteUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileDeleteUseCase) EXPECT() *MockFileDeleteUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockFileDeleteUseCase) Execute(ctx context.Context, fileName string) error.CustomError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, fileName)
	ret0, _ := ret[0].(error.CustomError)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockFileDeleteUseCaseMockRecorder) Execute(ctx, fileName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockFileDeleteUseCase)(nil).Execute), ctx, fileName)
}
